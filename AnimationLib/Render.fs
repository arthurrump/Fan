module Animation.Render

open FSharp.Data.UnitSystems.SI.UnitSymbols
[<Measure>] type ms
let ms = LanguagePrimitives.FloatWithMeasure<ms>

open Animation
open Browser
open Browser.Types
open Fable.Core

type RenderSettings =
    { Width : int
      Height : int
      Framerate : float</s> }

let defaultSettings =
    { Width = 1920
      Height = 1080
      Framerate = 25.</s> }

type FFmpegSettings =
    { ServerAddress : string
      InputArgs : string
      OutputArgs : string }

let runFFmpegSceneRender settings ffSettings renderer progress scene =
    let dt : float<ms> = 1000.<ms/s> / settings.Framerate
    let dur = Scene.singleDuration scene |> ms
    let sceneRenderFunc r = Scene.getRenderFunction false r scene
    let render = renderer sceneRenderFunc
    let timestamps = [ 0.<ms> .. dt .. (dur + dt) ]
    let frameCount = timestamps |> List.length
    let ffInput = ffSettings.InputArgs |> window.encodeURIComponent
    let ffOutput = ffSettings.OutputArgs |> window.encodeURIComponent
    let ws = WebSocket.Create ($"ws://{ffSettings.ServerAddress}?ffInput=%s{ffInput}&ffOutput=%s{ffOutput}")
    let wsProcessor = MailboxProcessor.Start(fun proc -> 
        let rec loop nextFrame = async {
            let! frame = proc.Receive ()
            let frame = min frame (frameCount - 1)
            printfn "Rendering frames %i to %i" nextFrame frame
            progress (nextFrame, frameCount)
            for t in timestamps.[nextFrame .. frame] do
                let buffer = render t
                ws.send buffer
            if frame >= frameCount - 1 then
                printfn "Done. Closing websocket."
                progress (frameCount, frameCount)
                ws.close (1000)
                return ()
            else
                return! loop (frame + 1)
        }
        loop 0
    )
    let bufferSize = int (1.5 * settings.Framerate)
    ws.onmessage <- fun ev -> 
        let frame = int (unbox ev.data)
        wsProcessor.Post (frame + bufferSize)
    ws.onopen <- fun _ ->
        printfn "WebSocket opened, rendering %i frames" frameCount
        progress (0, frameCount)
        wsProcessor.Post bufferSize

let ffmpegProres4444Output outFile =
    [ // Use the prores_ks encoder
      "-c:v"; "prores_ks" 
      // With the ProRes 4444 profile
      "-profile:v"; "4" 
      // Use YUVA pixel format with alpha channel
      "-pix_fmt"; "yuva444p10le" 
      // Set some flags that make this look like it's generated by an Apple product
      "-movflags"; "write_colr" 
      "-flags"; "bitexact" 
      "-chunk_duration"; "500K"
      "-metadata:s"; "\"encoder=Apple ProRes 4444\"" 
      "-vendor"; "apl0" 
      "-timecode"; "10:00:00:00" 
      // Write the output to this file
      $"%s{outFile}.mov"
    ] |> String.concat " "        

module CanvasRender =
    type [<AllowNullLiteral>] OffscreenCanvas =
        abstract height : float with get, set
        abstract width : float with get, set
        [<Emit("$0.getContext('2d'{{, $1}})")>] 
        abstract getContext_2d: ?contextAttributes: obj -> CanvasRenderingContext2D
        abstract getContext : contextId : string * ?contextAttributes : obj -> obj
        
    type [<AllowNullLiteral>] OffscreenCanvasType =
        [<Emit("new $0($1...)")>]
        abstract Create : width : int * height : int -> OffscreenCanvas

    let [<Global>] OffscreenCanvas : OffscreenCanvasType = jsNative

    let ffmpegRawCanvasInput settings =
        [ // Force the input format to raw video
          "-f"; "rawvideo" 
          // The raw data is in RGBA format, 4 bytes per pixel
          "-pixel_format"; "rgba" 
          // Get settings for the video parameters
          "-video_size"; $"%i{settings.Width}x%i{settings.Height}"
          "-framerate"; string settings.Framerate
        ] |> String.concat " "

    let rawCanvasRenderer settings renderFunc = 
        let canvas = OffscreenCanvas.Create (settings.Width, settings.Height)
        let ctx = canvas.getContext_2d ()
        fun (t : float<ms>) ->
            renderFunc ctx (float t)
            let image = ctx.getImageData (0., 0., canvas.width, canvas.height)
            image.data

    let canvasToProres server settings filename =
        { ServerAddress = server
          InputArgs = ffmpegRawCanvasInput settings
          OutputArgs = ffmpegProres4444Output filename }

    let runFFmpegCanvasRender server settings progress scene =
        let ffSettings = canvasToProres server settings scene.Title
        runFFmpegSceneRender settings ffSettings (rawCanvasRenderer settings) progress scene
