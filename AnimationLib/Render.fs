module Animation.Render

open FSharp.Data.UnitSystems.SI.UnitSymbols
[<Measure>] type ms
let ms = LanguagePrimitives.FloatWithMeasure<ms>

open Animation
open Browser
open Browser.Types
open Fable.Core

type RenderSettings =
    { Width : int
      Height : int
      Framerate : float</s> }

let defaultSettings =
    { Width = 1920
      Height = 1080
      Framerate = 25.</s> }

type FFmpegSettings =
    { ServerAddress : string
      InputArgs : string
      OutputArgs : string }

let runFFmpegRender settings ffSettings render duration progress =
    let dt : float<ms> = 1000.<ms/s> / settings.Framerate
    let dur = duration |> ms
    let timestamps = [ 0.<ms> .. dt .. (dur + dt) ]
    let frameCount = timestamps |> List.length
    let ffInput = ffSettings.InputArgs |> window.encodeURIComponent
    let ffOutput = ffSettings.OutputArgs |> window.encodeURIComponent
    Async.FromContinuations (fun (success, exc, cancel) -> 
        let ws = WebSocket.Create ($"ws://{ffSettings.ServerAddress}?ffInput=%s{ffInput}&ffOutput=%s{ffOutput}")
        let wsProcessor = MailboxProcessor.Start(fun proc -> 
            let rec loop nextFrame = async {
                let! frame = proc.Receive ()
                let frame = min frame (frameCount - 1)
                printfn "Rendering frames %i to %i" nextFrame frame
                progress (float (float nextFrame * dt))
                for t in timestamps.[nextFrame .. frame] do
                    let buffer = render t
                    ws.send buffer
                if frame >= frameCount - 1 then
                    printfn "Done. Closing websocket."
                    progress (float (dur + dt))
                    ws.close (1000)
                    success ()
                    return ()
                else
                    return! loop (frame + 1)
            }
            loop 0
        )
        let bufferSize = int (1.5 * settings.Framerate)
        ws.onmessage <- fun ev -> 
            let frame = int (unbox ev.data)
            wsProcessor.Post (frame + bufferSize)
        ws.onopen <- fun _ ->
            printfn "WebSocket opened, rendering %i frames" frameCount
            progress 0.
            wsProcessor.Post bufferSize
    )

type FFmpegSceneSettings = 
    { ServerAddress : string 
      InputArgs : string
      Filename : string
      VideoOutputArgs : string -> string
      ImageOutputArgs : string -> string }

let runFFmpegSceneRender settings ffSettings renderer progress scene =
    async {
        let sceneRenders = Scene.getSplitRenderFunctions scene
        let sceneRenders, totalDur = 
            sceneRenders |> List.mapFold (fun total (t, render, duration) -> (t, render, duration, total), total + duration) 0.
        for (name, render, duration, totalDurUptoHere) in sceneRenders do
            let render = renderer render
            let filename = $"%s{ffSettings.Filename}_%s{name}"
            let ffSettings =
                { ServerAddress = ffSettings.ServerAddress
                  InputArgs = ffSettings.InputArgs
                  OutputArgs = ffSettings.VideoOutputArgs filename }
            do! runFFmpegRender settings ffSettings render duration (fun t -> progress (t + totalDurUptoHere, totalDur))
        let runRender = renderer (fun r -> Scene.getRunRenderFunction r scene)
        let runDuration = Animation.singleDuration scene.RunAnimation.Duration |> ms
        let runStartFilename = $"%s{ffSettings.Filename}_1_run_0"
        let runStartFfSettings =
            { ServerAddress = ffSettings.ServerAddress
              InputArgs = ffSettings.InputArgs
              OutputArgs = ffSettings.ImageOutputArgs runStartFilename }
        do! runFFmpegRender settings runStartFfSettings runRender 0. (fun _ -> progress (totalDur, totalDur))
        if runDuration <> 0.<ms> then
            let runEndFilename = $"%s{ffSettings.Filename}_1_run_2"
            let runEndFfSettings = 
                { ServerAddress = ffSettings.ServerAddress
                  InputArgs = ffSettings.InputArgs
                  OutputArgs = ffSettings.ImageOutputArgs runEndFilename }
            do! runFFmpegRender settings runEndFfSettings (fun t -> runRender (t + runDuration)) 0. (fun _ -> progress (totalDur, totalDur))
    }

let ffmpegProres4444Output outFile =
    [ // Use the prores_ks encoder
      "-c:v"; "prores_ks" 
      // With the ProRes 4444 profile
      "-profile:v"; "4" 
      // Use YUVA pixel format with alpha channel
      "-pix_fmt"; "yuva444p10le" 
      // Set some flags that make this look like it's generated by an Apple product
      "-movflags"; "write_colr" 
      "-flags"; "bitexact" 
      "-chunk_duration"; "500K"
      "-metadata:s"; "\"encoder=Apple ProRes 4444\"" 
      "-vendor"; "apl0" 
      "-timecode"; "10:00:00:00" 
      // Write the output to this file
      $"%s{outFile}.mov"
    ] |> String.concat " "

let ffmpegPngOutput outFile =
    [ // Use image2 muxer and png encoder
      "-f"; "image2"
      "-c:v"; "png"
      // Only write a single frame
      "-frames:v"; "1"
      // File
      $"%s{outFile}.png" 
    ] |> String.concat " "

module CanvasRender =
    type [<AllowNullLiteral>] OffscreenCanvas =
        abstract height : float with get, set
        abstract width : float with get, set
        [<Emit("$0.getContext('2d'{{, $1}})")>] 
        abstract getContext_2d: ?contextAttributes: obj -> CanvasRenderingContext2D
        abstract getContext : contextId : string * ?contextAttributes : obj -> obj
        
    type [<AllowNullLiteral>] OffscreenCanvasType =
        [<Emit("new $0($1...)")>]
        abstract Create : width : int * height : int -> OffscreenCanvas

    let [<Global>] OffscreenCanvas : OffscreenCanvasType = jsNative

    let ffmpegRawCanvasInput settings =
        [ // Force the input format to raw video
          "-f"; "rawvideo" 
          // The raw data is in RGBA format, 4 bytes per pixel
          "-pixel_format"; "rgba" 
          // Get settings for the video parameters
          "-video_size"; $"%i{settings.Width}x%i{settings.Height}"
          "-framerate"; string settings.Framerate
        ] |> String.concat " "

    let rawCanvasRenderer settings renderFunc = 
        let canvas = OffscreenCanvas.Create (settings.Width, settings.Height)
        let ctx = canvas.getContext_2d ()
        fun (t : float<ms>) ->
            renderFunc ctx (float t)
            let image = ctx.getImageData (0., 0., canvas.width, canvas.height)
            image.data

    let canvasToProres server settings filename =
        { ServerAddress = server
          Filename = filename
          InputArgs = ffmpegRawCanvasInput settings
          VideoOutputArgs = ffmpegProres4444Output
          ImageOutputArgs = ffmpegPngOutput }

    let runFFmpegCanvasRender server settings progress scene =
        let ffSettings = canvasToProres server settings scene.Title
        runFFmpegSceneRender settings ffSettings (rawCanvasRenderer settings) progress scene
