module Render

open FSharp.Data.UnitSystems.SI.UnitSymbols
[<Measure>] type ms

open Animation
open Browser
open Browser.Types
open Fable.Core

type [<AllowNullLiteral>] OffscreenCanvas =
    abstract height : float with get, set
    abstract width : float with get, set
    [<Emit("$0.getContext('2d'{{, $1}})")>] 
    abstract getContext_2d: ?contextAttributes: obj -> CanvasRenderingContext2D
    abstract getContext : contextId : string * ?contextAttributes : obj -> obj

type [<AllowNullLiteral>] OffscreenCanvasType =
    [<Emit("new $0($1...)")>]
    abstract Create : width : int * height : int -> OffscreenCanvas

let [<Global>] OffscreenCanvas : OffscreenCanvasType = jsNative

type RenderSettings =
    { Width : int
      Height : int
      Framerate : float</s> }

let defaultSettings =
    { Width = 300
      Height = 150
      Framerate = 30.</s> }

let private ffmpegRawInput settings =
    [ // Force overwriting files
      "-y"
      // Force the input format to raw video
      "-f"; "rawvideo" 
      // The raw data is in RGBA format, 4 bytes per pixel
      "-pixel_format"; "rgba" 
      // Get settings for the video parameters
      "-video_size"; $"%i{settings.Width}x%i{settings.Height}"
      "-framerate"; string settings.Framerate
    ] |> String.concat " "

let private ffmpegProres4444Output outFile =
    [ // Use the prores_ks encoder
      "-c:v"; "prores_ks" 
      // With the ProRes 4444 profile
      "-profile:v"; "4" 
      // Use YUVA pixel format with alpha channel
      "-pix_fmt"; "yuva444p10le" 
      // Set some flags that make this look like it's generated by an Apple product
      "-movflags"; "write_colr" 
      "-flags"; "bitexact" 
      "-chunk_duration"; "500K"
      "-metadata:s"; "\"encoder=Apple ProRes 4444\"" 
      "-vendor"; "apl0" 
      "-timecode"; "10:00:00:00" 
      // Write the output to this file
      $"%s{outFile}.mov"
    ] |> String.concat " "

let runRender scene =
    let settings = { defaultSettings with Width = 1920; Height = 1080; Framerate = 25.</s> }
    let canvas = OffscreenCanvas.Create (settings.Width, settings.Height)
    let ctx = canvas.getContext_2d ()
    let render = 
        let r = Scene.getRenderFunction false ctx scene
        fun (t : float<ms>) ->
            r (float t)
            let image = ctx.getImageData (0., 0., canvas.width, canvas.height)
            image.data
    let dt : float<ms> = 1000.<ms/s> / settings.Framerate
    let dur = LanguagePrimitives.FloatWithMeasure (Scene.singleDuration scene)
    let timestamps = [ 0.<ms> .. dt .. (dur + dt) ]
    let frameCount = timestamps |> List.length |> string
    let ffInput = ffmpegRawInput settings |> window.encodeURIComponent
    let ffOutput = ffmpegProres4444Output scene.Title |> window.encodeURIComponent
    let ws = WebSocket.Create ($"ws://localhost:5000?ffInput=%s{ffInput}&ffOutput=%s{ffOutput}")
    ws.onmessage <- fun ev -> 
        printfn "WebSocket: %s" (unbox ev.data)
    ws.onopen <- fun _ ->
        printfn "WebSocket opened, rendering %s frames" frameCount
        for t in timestamps do
            let buffer = render t
            ws.send buffer
        ws.close (1000)
    ()
